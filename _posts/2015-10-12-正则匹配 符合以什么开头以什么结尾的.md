---
layout: post
title: 正则匹配 符合以什么开头以什么结尾的
date: 2015-10-12 20:25
categories: [java]
tags: [java, 正则]
---
`java 

private static String getQuestionResolution(String html){ 

        String regex = "【解析】([\\s\\S]*?)【"; 

        Matcher matcher = Pattern.compile(regex).matcher(html); 

        if (matcher.find()){ 

            return matcher.group(1).trim(); 

        } 

        return ""; 

    } 
`
上面一段代码，表示以【解析】开头，以【结尾。
并且将符合这种类型的给分割，获取全部属于这种类型的。
解释：
我们是为了获取所有以【解析】开头，以【结尾 的数据。
[]是匹配包含的任意字符，而我们这里匹配[\s\S]
因为：
\s
匹配任何空白字符，包括空格、制表符、换页符等。与 [ \f\n\r\t\v] 等效。
\S
匹配任何非空白字符。与 [^ \f\n\r\t\v] 等效。
接着我们又要获取全部匹配这种类型的。
所以依据表达式：
*
零次或多次匹配前面的字符或子表达式。例如，zo* 匹配“z”和“zoo”。* 等效于 {0,}。
而我们又担心这种情况出现。
就是要解析这么一段文本：
【解析】111【结束】
【解析】222【结束】
【解析】333【结束】
我们要获取的是111 222 333，而不是第一个【解析】和第三个【结束】之间的数据：
111【结束】
【解析】222【结束】
【解析】333
所以我们要紧跟随一个字符：?
? 此字符有两种用法：
?
第一种：
当此字符紧随任何其他限定符（*、+、?、{n}、{n,}、{n,m}）之后时，匹配模式是“非贪心的”。“非贪心的”模式匹配搜索到的、尽可能短的字符串，而默认的“贪心的”模式匹配搜索到的、尽可能长的字符串。例如，在字符串“oooo”中，“o+?”只匹配单个“o”，而“o+”匹配所有“o”。
第二种：
零次或一次匹配前面的字符或子表达式。例如，“do(es)?”匹配“do”或“does”中的“do”。? 等效于 {0,1}。
